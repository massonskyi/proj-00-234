### Листинг программы

### fonts - шрифты
### assets - иконки
### requirements - необходимые библиотеки для сборки проекта
### .gitignore - локальный контент, не отправляется на github

### Аннотация
    /// file.py - файл
        ///
        ... - блок данных
        ///

/// main.py

from PySide6 import QtWidgets
from PySide6.QtWidgets import QMessageBox

from gui.startmenu import Ui_StartMenu


def check_configuration():
    import os
    if not os.path.exists("./configuration_config_mdt.json"):
        QMessageBox.information(None, "Warning",
                                "Configuration file not found. Run the configuration_config_mdt.py script.")
        from utils.configuration_config_mdt import ConfigurationMDTH
        try:
            ConfigurationMDTH.create_configuration_config_mdt().save_as_json()
        except Exception as e:
            QMessageBox.critical(None, "Error", str(e))
            return False
        else:
            QMessageBox.information(None, "Success", "Configuration file created successfully.")
            return True


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    check_configuration()
    try:
        MainWindow = Ui_StartMenu()
        MainWindow.show()
    except Exception as e:
        QMessageBox.critical(None, "Error", str(e))

    sys.exit(app.exec())


///
/// UTILS
/// configuration_config_mdt.py
from typing import List

import json


class ConfigurationMDTH:
    headers: List[str] = ['№ п/п', 'Показатель', ' ']
    idx: List[str] = [
        '[', '--', '---',
        '1',
        '2',
        '3', '3.1', '3.1c', '3.1nc', '3.2', '3.3', '3.4', '3.5', '3.6', '-', '4', '4.1', '4.1c', '4.1nc', '4.1.1',
        '4.1.1c',
        '4.1.1nc', '4.1.2', '4.1.2c', '4.1.2nc',
        '4.1.3', '4.1.3c', '4.1.3nc', '4.1.4', '4.1.4c',
        '4.1.4nc', '4.1.5', '4.1.5c', '4.1.5nc', '4.1.6', '4.1.6c',
        '4.1.6nc', '4.1.7', '4.1.7c', '4.1.7nc', '4.1.8', '4.1.8c', '4.1.8nc',
        '4.2', '4.2.1', '4.2.2', '4.2.3', '4.2.4', '4.2.5', '4.2.6', '4.2.7', '4.2.8',
        '4.3', '4.3.1', '4.3.2', '4.3.3', '4.3.4', '4.3.5', '4.3.6', '4.3.7', '4.3.8',
        '4.4', '4.4.1', '4.4.2', '4.4.3', '4.4.4', '4.4.5', '4.4.6',
        '4.5', '4.5.1', '4.5.2', '4.5.3', '4.5.4', '4.5.5', '4.5.6',
        '4.6', '4.6.1', '4.6.2', '4.6.3', '4.6.4', '4.6.5', '4.6.6', '4.6.7', '4.6.8',
        '4.7', '4.7.1', '4.7.2', '4.7.3', '4.7.4', '4.7.5', '4.7.6', '4.7.7', '4.7.8',
        '5', '5.1', '5.2', '5.3', '5.4',
        '5.5', '5.5p', '5.5.1', '5.5.1p', '5.5.2', '5.5.2p', '5.5.3', '5.5.3p', '5.5.4', '5.5.4p', '5.5.5', '5.5.5p',
        '5.5.6', '5.5.6p',
        '5.6', '5.6p', '5.6.1p', '5.6.2', '5.6.2p', '5.6.3', '5.6.3p', '5.6.4', '5.6.4p',
        '5.7', '5.7p', '5.7.1', '5.7.1p', '5.7.2', '5.7.2p', '5.7.3', '5.7.3p', '5.7.4', '5.7.4p', '5.7.5', '5.7.5p',
        '5.7.6', '5.7.6p', '5.7.7', '5.7.7p',
        '5.8', '5.8p', '5.8d', '5.8.1', '5.8.2', '5.8.3', '5.8.3p', '5.8.4', '5.8.4p', '5.8.5', '5.8.5p',
        '6',
        '6.1', '6.1.1', '6.1.2', '6.1.3', '6.1.4', '6.1.5', '6.1.6', '+',
        '6.2', '6.2.1', '6.2.2', '6.2.3', '6.2.4', '6.2.5', '6.2.6', '.',
        '6.3', '6.3.1', '6.3.2', '6.3.3', '6.3.4', '6.3.5', '6.3.6', '_',
        '6.4', '6.4.1', '6.4.2', '6.4.3', '6.4.4', '6.4.5', '6.4.6', '=',
        '6.5', '6.5.1', '6.5.2', '6.5.3', '6.5.4', '6.5.5', '6.5.6', '/',
        '6.6', '6.6.1', '6.6.2', '6.6.3', '6.6.4', '6.6.5', '6.6.6', '|',
        '6.7',  '6.7.1',  '6.7.2',  '6.7.3',  '6.7.4',  '6.7.5',  '6.7.6', '"',
        '6.8',  '6.8.1',  '6.8.2',  '6.8.3',  '6.8.4',  '6.8.5',  '6.8.6', ']',
    ]

    data: List[int] = [
        '(Ввод текста)',
        '(Ввод текста)',
        '(Ввод текста)',
        '(Ввод текста)',
        '(Ввод текста)',
        '(Автосумма)\n=3.1+3.2+3.3+3.4+3.5+3.6',
        '(Автосумма)\n=3.1c+3.1nc',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=4.1+4.2+4.3+4.4+4.5+4.6+4.7',
        '(Автосумма)\n=4.1c+4.1mc',
        '(Автосумма)\n=4.1.1c+4.1.2c+4.1.3c+4.1.4c+4.1.5c+4.1.6c+4.1.7c+4.1.8c',
        '(Автосумма)\n=4.1.1nc+4.1.2nc+4.1.3nc+4.1.4nc+4.1.5nc+4.1.6nc+4.1.7nc+4.1.8nc',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        ' ',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.2.1+4.2.2+4.2.3+4.2.4+4.2.5+4.2.6+4.2.7+4.2.8',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.3.1+4.3.2+4.3.3+4.3.4+4.3.5+4.3.6+4.3.7+4.3.8',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.4.1+4.4.2+4.4.3+4.4.4+4.4.5+4.4.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.5.1+4.5.2+4.5.3+4.5.4+4.5.5+4.5.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.6.1+4.6.2+4.6.3+4.6.4+4.6.5+4.6.6+4.6.7+4.6.8',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=4.7.1+4.7.2+4.7.3+4.7.4+4.7.5+4.7.6+4.7.7+4.7.8',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=5.5.1+5.5.2+5.5.3+5.5.4+5.5.5+5.5.6',
        '(Автосумма)\n=5.5.1p+5.5.2p+5.5.3p+5.5.4p+5.5.5p+5.5.6p',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=5.6.1+5.6.2+5.6.3+5.6.4',
        '(Автосумма)\n=5.6.1p+5.6.2p+5.6.3p+5.6.4p',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Автосумма)\n=6.1+6.2+6.3+6.4+6.5+6.6+6.7+6.8',
        '(Автосумма)\n=6.1.1+6.1.2+6.1.3+6.1.4+6.1.5+6.1.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.2.1+6.2.2+6.2.3+6.2.4+6.2.5+6.2.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.3.1+6.3.2+6.3.3+6.3.4+6.3.5+6.3.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.4.1+6.4.2+6.4.3+6.4.4+6.4.5+6.4.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.5.1+6.5.2+6.5.3+6.5.4+6.5.5+6.5.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.6.1+6.6.2+6.6.3+6.6.4+6.6.5+6.6.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.7.1+6.7.2+6.7.3+6.7.4+6.7.5+6.7.6',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
        '(Автосумма)\n=6.8.1+6.8.2+6.8.3+6.8.4+6.8.5+6.8.6',
        '(Ввод текста)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод числа)',
        '(Ввод текста)',
    ]
    upload: List[dict]
    names: List[str] = [
        'Перечень нормативных актов, принятых в субъекте РФ по организации социальной занятости инвалидов',
        'Проблемы, возникающие в субъекте РФ при организации социальной занятости инвалидов',
        'Пути своевременного решения возникающих проблем',
        'Орган исполнительной власти субъекта Российской Федерации, который осуществляет организацию и координацию межведомственного взаимодействия по социальной занятости в субъекте Российской Федерации',
        'Перечень органов исполнительной власти субъекта Российской Федерации, включенных в межведомственное взаимодействие при организации социальной занятости',
        'Количество организаций, уполномоченных на осуществление деятельности по социальной занятости инвалидов, определяются органами государственной власти субъектов Российской Федерации',
        'государственных организаций системы социальной защиты и социального обслуживания всего',
        'стационарных',
        'нестационарных',
        'организаций, осуществляющих образовательную деятельность,',
        'организаций здравоохранения',
        'социально ориентированных негосударственных организаций',
        'организаций, осуществляющих деятельность по сопровождаемой трудовой деятельности инвалидов',
        'иных организациях',
        'указать каких',
        'Оказано услуг по социальной занятости уполномоченными организациями',
        'организациями системы социальной защиты и социального обслуживания',
        'стационарных',
        'нестационарных',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда;',
        'стационарных',
        'нестационарных',
        'услуги, направленные на обучение инвалидов навыкам, необходимым для выполнения трудовых действий, правилам трудового распорядка, нормам труда и социального взаимодействия;',
        'стационарных',
        'нестационарных',
        'услуги, направленные на организацию доступных для инвалидов производственных процессов с несложными (простыми) видами труда, на адаптацию рабочих мест для участия инвалидов в производственных процессах и на обеспечение доступных для инвалидов трудовых обязанностей;',
        'стационарных',
        'нестационарных',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'стационарных',
        'нестационарных',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'стационарных',
        'нестационарных',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'стационарных',
        'нестационарных',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'стационарных',
        'нестационарных',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'стационарных',
        'нестационарных',
        'организациями, осуществляющими образовательную деятельность',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда;',
        'услуги, направленные на обучение инвалидов навыкам, необходимым для выполнения трудовых действий, правилам трудового распорядка, нормам труда и социального взаимодействия;',
        'услуги, направленные на организацию доступных для инвалидов производственных процессов с несложными (простыми) видами труда, на адаптацию рабочих мест для участия инвалидов в производственных процессах и на обеспечение доступных для инвалидов трудовых обязанностей;',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'организациями культуры',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда, занятости;',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'организациями спорта',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда, занятости;',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'социально ориентированными негосударственными организациями',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда;',
        'услуги, направленные на обучение инвалидов навыкам, необходимым для выполнения трудовых действий, правилам трудового распорядка, нормам труда и социального взаимодействия;',
        'услуги, направленные на организацию доступных для инвалидов производственных процессов с несложными (простыми) видами труда, на адаптацию рабочих мест для участия инвалидов в производственных процессах и на обеспечение доступных для инвалидов трудовых обязанностей;',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'организациями, осуществляющими деятельность по сопровождаемой трудовой деятельности инвалидов',
        'услуги, направленные на определение нуждаемости инвалидов в организации социальной занятости, на подбор подходящих инвалидам несложных (простых) видов труда;',
        'услуги, направленные на обучение инвалидов навыкам, необходимым для выполнения трудовых действий, правилам трудового распорядка, нормам труда и социального взаимодействия;',
        'услуги, направленные на организацию доступных для инвалидов производственных процессов с несложными (простыми) видами труда, на адаптацию рабочих мест для участия инвалидов в производственных процессах и на обеспечение доступных для инвалидов трудовых обязанностей;',
        'услуги, направленные на организацию несложных (простых) видов развивающей (целенаправленной) деятельности для инвалидов, имеющих выраженные затруднения в участии в труде с помощью других лиц;',
        'услуги, направленные на организацию социального взаимодействия участников социальной занятости, а также на организацию их отдыха (перерывов) во время социальной занятости;',
        'услуги, обеспечивающие участие инвалидов в социальной занятости, включая социально-психологическое, социально-педагогическое сопровождение и ассистивные услуги по персональной помощи инвалидам в передвижении, получении информации, в ориентации и коммуникации;',
        'услуги, обеспечивающие уход за инвалидами во время их участия в социальной занятости (помощь при одевании и раздевании, смене абсорбирующего белья, приеме пищи, питья и других гигиенических процедурах);',
        'услуги по сопровождению передвижения инвалидов от места жительства к месту участия в социальной занятости и обратно.',
        'Численность инвалидов, включенных в социальную занятость всего', 'из них с психическими расстройствами',
        'из них детей старше 14 лет', 'из них находящихся на постоянном сопровождаемом проживании',
        'из них проживающих в семьях',
        'в специально созданных производственных мастерских, всего в т.ч. в организациях',
        'из них с психическими расстройствами',
        'государственных организациях социального обслуживания (нестационарных) всего',
        'из них с психическими расстройствами', 'государственных организациях образования всего',
        'из них с психическими расстройствами', 'государственных организациях культуры всего',
        'из них с психическими расстройствами', 'государственных организациях здравоохранения всего',
        'из них с психическими расстройствами', 'социально ориентированных негосударственных организациях всего',
        'из них с психическими расстройствами', 'иных организациях всего', 'из них с психическими расстройствами',
        'в подсобных хозяйствах, на производстве и переработке сельскохозяйственной продукции',
        'из них с психическими расстройствами',
        'государственных организациях социального обслуживания (нестационарных)',
        'из них с психическими расстройствами', 'государственных организациях образования',
        'из них с психическими расстройствами', 'социально ориентированных негосударственных организациях',
        'из них с психическими расстройствами', 'иных организациях', 'из них с психическими расстройствами',
        'в развивающую и творческую деятельность (строки не складываются):', 'из них с психическими расстройствами',
        'в государственных организациях социального обслуживания (нестационарных)',
        'из них с психическими расстройствами', 'в государственных организациях образования',
        'из них с психическими расстройствами', 'в спортивных государственных организациях',
        'из них с психическими расстройствами', 'в государственных организациях культуры',
        'из них с психическими расстройствами', 'в государственных организациях здравоохранения',
        'из них с психическими расстройствами', 'в социально ориентированных негосударственных организациях',
        'из них с психическими расстройствами', 'в иных организациях', 'из них с психическими расстройствами',
        'проживающих в стационарных организациях социального обслуживания', 'из них с психическими расстройствами',
        'Доля включенных в социальную занятость (и проживающих в стационарных организациях социального обслуживания (5.8)) от общего числа приживающих в стационарных организациях социального обслуживания (%)',
        'из них дети старше 14 лет', 'из них с психическими расстройствами', 'в специально созданных мастерских',
        'из них с психическими расстройствами', 'в подсобных хозяйствах', 'из них с психическими расстройствами',
        'в развивающую и творческую деятельность', 'из них с психическими расстройствами',
        'В предоставлении услуг социальной занятости заняты специалисты:',
        'в государственных организациях социального обслуживания (нестационарных)', 'специалист по социальной работе',
        'социальный педагог', 'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты',
        'указать какие специалисты', 'в государственных организациях социального обслуживания (стационарных)',
        'специалист по социальной работе', 'социальный педагог', 'инструктор по труду', 'психолог',
        'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в государственных организациях образования', 'специалист по социальной работе', 'социальный педагог',
        'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в спортивных государственных организациях', 'специалист по социальной работе', 'социальный педагог',
        'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в государственных организациях культуры', 'специалист по социальной работе', 'социальный педагог',
        'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в государственных организациях здравоохранения', 'специалист по социальной работе', 'социальный педагог',
        'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в социально ориентированных негосударственных организациях', 'специалист по социальной работе',
        'социальный педагог', 'инструктор по труду', 'психолог', 'социальный работник', 'иные специалисты',
        'указать какие специалисты', 'в иных организациях', 'указать в каких организациях',
        'специалист по социальной работе', 'социальный педагог', 'инструктор по труду', 'психолог',
        'социальный работник', 'иные специалисты', 'указать какие специалисты',
        'в государственных организациях культуры',
        'специалист по социальной работе',
        'социальный педагог',
        'инструктор по труду',
        'психолог',
        'социальный работник',
        'иные специалисты',
        'указать какие специалисты',
        'в государственных организациях здравоохранения',
        'специалист по социальной работе',
        'социальный педагог',
        'инструктор по труду',
        'психолог',
        'социальный работник',
        'иные специалисты',
        'указать какие специалисты',
        'в социально ориентированных негосударственных организациях',
        'специалист по социальной работе',
        'социальный педагог',
        'инструктор по труду',
        'психолог',
        'социальный работник',
        'иные специалисты',
        'указать какие специалисты',
        'в иных организациях',
        'указать в каких организациях',
        'специалист по социальной работе',
        'социальный педагог',
        'инструктор по труду',
        'психолог',
        'социальный работник',
        'иные специалисты',
        'указать какие специалисты'
    ]
    file: str

    @classmethod
    def create_configuration_config_mdt(cls, path=None):
        if not path:
            cls.file = './configuration_config_mdt.json'
        else:
            cls.file = path + '/configuration_config_mdt.json'

        cls.upload = [{"idx": cls.headers[0], "name": cls.headers[1], "data": cls.headers[2]}]
        for idx, name, data_item in zip(cls.idx, cls.names, cls.data):
            cls.upload.append({"idx": idx, "name": name, "data": data_item})

        return cls

    @classmethod
    def save_as_json(cls):
        with open(cls.file, 'w', encoding='utf-8') as f:
            json.dump(cls.upload, f, ensure_ascii=False, indent=4)

///
/// loaders.py
from PySide6 import QtCore
from PySide6.QtGui import QIcon, QPixmap


def load_icon(filename: str) -> QIcon:
    """
    Load an icon from a file, resize it to 30x30 pixels, and return as a QIcon.
    :param filename: Name of the icon file
    :return: QIcon object
    """
    pixmap = QPixmap(filename)
    if not pixmap.isNull():
        pixmap = pixmap.scaled(75, 75, QtCore.Qt.KeepAspectRatio, QtCore.Qt.SmoothTransformation)
        return QIcon(pixmap)
    return QIcon()  # Return an empty icon if loading fails
///
/// s2f.py

from typing import List


def save_to_word(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save to word data
    :param path: path to save to file
    :param result_data: Data to save to word file
    :param data: Data to save to word file
    :param textboxes: Text boxes to save to word file
    :return: True on success, False on failure + Exception
    """
    try:
        from docx import Document
    except ImportError:
        return False, Exception('docx module is not installed')

    data_ptr: dict | None = data[0].get('mdth', None)
    if not data_ptr:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    document = Document()
    document.add_heading("РЕЗУЛЬТАТЫ", level=1)

    table_main = document.add_table(rows=1, cols=3)

    for i, item in enumerate(data_ptr):
        row_cells_main = table_main.add_row().cells
        row_cells_main[0].text = item.get("idx", "")
        row_cells_main[1].text = item.get("name", "")

        if i < len(textboxes):
            row_cells_main[2].text = textboxes[i].text()

    if result_data:
        document.add_paragraph("\n")
        document.add_heading("Таблица результатов", level=2)

        table_results = document.add_table(rows=len(result_data), cols=len(result_data[0]) if result_data else 0)
        for row, row_data in enumerate(result_data):
            for col, value in enumerate(row_data):
                cell = table_results.cell(row, col)
                cell.text = str(value)
    try:
        document.save(f'{path}/export/Untitled.docx')
    except Exception as e:
        return False, Exception(e)
    else:
        return True, None


def save_to_excel(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to excel file
    :param path: path to save to file
    :param data: Data to save to excel file
    :param textboxes: Text boxes to save to excel file
    :return: True on success, False on failure + Exception
    """
    try:
        import pandas as pd
    except ImportError:
        return False, Exception('Pandas is not installed')

    data_prt: dict | None = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    data_list: List = [{'№ п/п': item.get("idx", ""), 'Показатель': item.get("name", ""),
                        'data': textboxes_ptr[i].text()} for i, item in enumerate(data_prt)]
    try:
        df_data = pd.DataFrame(data_list)
        df_result = pd.DataFrame(result_data) if result_data else None
    except Exception as e:
        return False, Exception(e)
    else:
        try:
            with pd.ExcelWriter(f'{path}/export/Untitled.xlsx') as writer:
                df_data.to_excel(writer, sheet_name='Data', index=False)
                if df_result is not None:
                    df_result.to_excel(writer, sheet_name='Result Data', index=False)
        except Exception as e:
            return False, Exception(e)
        else:
            return True, None


def save_to_pdf(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to pdf file
    :param path: path to save to file
    :param data: Data to save to pdf file
    :param textboxes: Text boxes to save to pdf file
    :param result_data: Result data to save to pdf file
    :return: True on success, False on failure + Exception
    """
    try:
        from fpdf import FPDF
    except ImportError:
        return False, Exception('FPDF is not installed')

    data_prt = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    class PDF(FPDF):
        """
        PDF class for saving data to pdf file
        """

        def header(self) -> None:
            """
            Set header of pdf file
            :return: None
            """
            self.set_font('Arial', 'B', 12)
            self.cell(0, 10, 'Data from Textboxes', 0, 1, 'C')

    pdf = PDF()
    pdf.add_page()

    font_path = './fonts/DejaVuSans.ttf'
    bold_dejavu_path = './fonts/DejaVuSansBold.ttf'

    pdf.add_font('DejaVu', '', font_path, uni=True)
    pdf.add_font('DejaVu-Bold', '', bold_dejavu_path, uni=True)
    pdf.set_font('DejaVu-Bold', '', 12)

    pdf.cell(200, 10, txt="Data from Textboxes", ln=True, align='C')

    for i, item in enumerate(data_prt):
        text = f"{item.get('idx', '')} | {item.get('name', '')} | {textboxes_ptr[i].text()}"
        pdf.set_font('DejaVu', '', 12)
        pdf.multi_cell(0, 10, txt=text)

    pdf.add_page()
    pdf.set_font('DejaVu-Bold', '', 12)
    pdf.cell(200, 10, txt="Result Data", ln=True, align='C')

    for row in result_data:
        text = " | ".join(row)
        pdf.set_font('DejaVu', '', 12)
        pdf.multi_cell(0, 10, txt=text)

    try:
        pdf.output(f'{path}/export/Untitled.pdf')
    except Exception as e:
        return False, Exception(e)
    else:
        return True, None


def save_to_csv(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to csv file with csv format
    :param path: path to save to file
    :param data: Data to save to csv file with csv format
    :param textboxes: Text boxes to save to csv file with csv format
    :param result_data: Result data to save to csv file
    :return: True on success, False on failure + Exception
    """
    try:
        import csv
    except ImportError:
        return False, Exception('CSV module is not installed')

    data_prt = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    file = None
    try:
        file = open(f"{path}/export/Untitled.csv", mode='w', newline='', encoding='utf-8')
        writer = csv.writer(file)

        writer.writerow(['№ п/п', 'Показатель', 'Ответ субъекта'])
        for i, item in enumerate(data_prt):
            writer.writerow([item.get("idx", ""), item.get("name", ""), textboxes_ptr[i].text()])

        writer.writerow([])

        writer.writerow(['Result Data'])
        for row in result_data:
            writer.writerow(row)

    except Exception as e:
        return False, Exception(e)
    else:
        return True, None
    finally:
        if file:
            file.close()


def save_to_txt(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to txt file
    :param path: path to save to file
    :param data: Data to save to txt file
    :param textboxes: Text boxes to save to txt file
    :param result_data: Result data to save to txt file
    :return: True on success, False on failure + Exception
    """
    data_prt: dict | None = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    file = None
    try:
        file = open(f'{path}/export/Untitled.txt', mode='w', encoding='utf-8')
    except Exception as e:
        return False, Exception(e)
    else:
        for i, item in enumerate(data_prt):
            line = (f"№ п/п: {item.get('idx', '')}, "
                    f"Показатель: {item.get('name', '')}, "
                    f"Ответ субъекта: {textboxes[i].text()}\n")
            try:
                file.write(line)
            except Exception as e:
                return False, Exception(e)

        file.write("\n")
        if result_data:
            file.write("Result Data:\n")

            for row in result_data:
                line = " | ".join(row) + "\n"

                try:
                    file.write(line)
                except Exception as e:
                    return False, Exception(e)

        else:
            return True, None
    finally:
        if file:
            file.close()


def save_to_xml(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data and result_data to xml file
    :param path: path to save to file
    :param data: Data to save to xml file
    :param textboxes: Text boxes to save to xml file
    :param result_data: Result data to save to xml file
    :return: True on success, False on failure + Exception
    """
    try:
        from xml.etree.ElementTree import Element, SubElement, ElementTree
    except ImportError:
        return False, Exception('XML is not installed')

    data_prt = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    root = Element('root')

    data_element = SubElement(root, 'data')
    for i, item in enumerate(data_prt):
        entry = SubElement(data_element, 'entry')
        SubElement(entry, 'number').text = item.get('idx', '')
        SubElement(entry, 'indicator').text = item.get('name', '')
        SubElement(entry, 'answer').text = textboxes_ptr[i].text()

    if result_data:
        result_element = SubElement(root, 'result_data')
        for row in result_data:
            entry = SubElement(result_element, 'entry')
            SubElement(entry, 'field1').text = row[0] if len(row) > 0 else ''
            SubElement(entry, 'field2').text = row[1] if len(row) > 1 else ''
            SubElement(entry, 'field3').text = row[2] if len(row) > 2 else ''

    tree = ElementTree(root)
    try:
        tree.write(f'{path}/export/Untitled.xml', encoding='utf-8', xml_declaration=True)
    except Exception as e:
        return False, Exception(e)
    else:
        return True, None


def save_to_json(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to json file with json format
    :param path: path to save to file
    :param data: Data to save to json file with json format
    :param textboxes: Text boxes to save to json file with json format
    :param result_data: Result data to save to json file
    :return: True on success, False on failure + Exception
    """
    try:
        import json
    except ImportError:
        return False, Exception('JSON is not installed')

    data_prt: dict | None = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    # Prepare data
    data_list = [{'№ п/п': item.get("idx", ""), 'Показатель': item.get("name", ""),
                  'data': textboxes_ptr[i].text()} for i, item in enumerate(data_prt)]

    result_list = [{'Field1': row[0], 'Field2': row[1], 'Field3': row[2]} for row in result_data] if result_data else []

    combined_data = {'data': data_list, 'result_data': result_list}

    file = None
    try:
        file = open(f'{path}/export/Untitled.json', mode='w', encoding='utf-8')
    except Exception as e:
        return False, Exception(e)
    else:
        try:
            json.dump(combined_data, file, indent=4, ensure_ascii=False)
        except Exception as e:
            return False, Exception(e)
        else:
            return True, None
    finally:
        if file:
            file.close()


def save_to_html(path: str, data: List, textboxes: List, result_data: List[List[str]]) -> [bool, Exception]:
    """
    Save data to html file with html format with html format
    :param path: path to save to file
    :param data: Data to save to html file with html format
    :param textboxes: Text boxes to save to html file with html format
    :param result_data: Result data to save to html file
    :return: True on success, False on failure + Exception
    """
    try:
        import pandas as pd
    except ImportError:
        return False, Exception('Pandas is not installed')

    data_prt: dict | None = data[0].get('mdth', None)
    if not data_prt:
        return False, Exception('Data cannot be empty')

    textboxes_ptr: List = textboxes
    if not textboxes_ptr:
        return False, Exception('Text boxes cannot be empty')

    # Prepare data
    data_list = [{'№ п/п': item.get("idx", ""), 'Показатель': item.get("name", ""),
                  'Ответ субъекта': textboxes_ptr[i].text()} for i, item in enumerate(data_prt)]
    data_df = pd.DataFrame(data_list)
    data_html = data_df.to_html(index=False)
    result_df = pd.DataFrame(result_data) if result_data else pd.DataFrame()
    result_html = result_df.to_html(index=False)
    try:
        with open(f'{path}/export/Untitled.html', mode='w', encoding='utf-8') as file:
            file.write("<html><head><title>Output HTML</title></head><body>\n")
            file.write("<h2>Data from Textboxes</h2>\n")
            file.write(data_html)
            file.write("<h2>Result Data</h2>\n")
            file.write(result_html)
            file.write("</body></html>")
    except Exception as e:
        return False, Exception(e)
    else:
        return True, None


def generate_mdth_file(data, filename: str, mode: str = "w", encoding: str = "utf-8") -> [bool, Exception]:
    """
    Generate markdown file from data
    :param data: data to save
    :param filename: file name to save markdown
    :param mode: (Optional) mode to save file
    :param encoding: (Optional) encoding to save file
    :return: True or False with Exception
    """
    try:
        import json
    except ImportError:
        return False, Exception('JSON is not installed')
    try:
        json_data = json.dumps(data, ensure_ascii=False, indent=4)
    except Exception as e:
        return False, e

    file = None
    try:
        file = open(filename, mode, encoding=encoding)
    except Exception as e:
        return False, Exception(e)
    else:
        file.write(json_data)
        return True, None
    finally:
        if file:
            file.close()


def load_mdth_file(filename: str) -> [bool, Exception]:
    """
    Load markdown file from file
    :param filename:  file name to load
    :return: load markdown
    """
    import json
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            content = f.read()
            data = json.loads(content)
            return data

    except FileNotFoundError:
        print(f"Файл '{filename}' не найден.")
        return None
    except json.JSONDecodeError as e:
        print(f"Ошибка при чтении файла '{filename}': {e}")
        return None

///
/// GUI
/// WIDGETS
/// bashconsole
import os
import platform
import sys
import subprocess

from PySide6.QtGui import QTextCursor
from PySide6.QtWidgets import QApplication, QPlainTextEdit, QVBoxLayout, QWidget
from PySide6.QtCore import Qt, QThread, Signal


class CommandThread(QThread):
    outputReceived = Signal(str)
    commandFinished = Signal()

    def __init__(self, command):
        super().__init__()
        self.command = command

    def run(self):
        process = subprocess.Popen(self.command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        for line in iter(process.stdout.readline, ''):
            self.outputReceived.emit(line)
        for line in iter(process.stderr.readline, ''):
            self.outputReceived.emit(line)
        process.stdout.close()
        process.stderr.close()
        process.wait()
        self.commandFinished.emit()


class CustomBashConsole(QPlainTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle('Bash Console')
        self.setReadOnly(False)
        self.prompt = f'{os.getcwd()}$ '
        self.insertPlainText(self.prompt)
        self.commandThread = None
        self.display_system_info()

    def display_system_info(self):
        system_info = (
            f"System: {platform.system()}\n"
            f"Node Name: {platform.node()}\n"
            f"Release: {platform.release()}\n"
            f"Version: {platform.version()}\n"
            f"Machine: {platform.machine()}\n"
            f"Processor: {platform.processor()}\n"
        )
        self.insertPlainText(system_info + "\n")
        self.insertPlainText(self.prompt)

    def keyPressEvent(self, event):
        if event.key() in [Qt.Key_Return, Qt.Key_Enter]:
            cursor = self.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            line = cursor.block().text()[len(self.prompt):]
            self.run_command(line)
        else:
            super().keyPressEvent(event)

    def run_command(self, command):
        self.insertPlainText('\n')
        self.setReadOnly(True)
        self.commandThread = CommandThread(command)
        self.commandThread.outputReceived.connect(self.append_output)
        self.commandThread.commandFinished.connect(self.command_finished)
        self.commandThread.start()

    def append_output(self, text):
        self.insertPlainText(text)

    def command_finished(self):
        self.insertPlainText(self.prompt)
        self.setReadOnly(False)

///
/// customwidgetitem.py
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLineEdit


class CustomWidgetItem(QWidget):
    def __init__(self, textline, parent=None):
        super().__init__(parent)
        self.include_objects = []
        self.initUI(textline)

    def initUI(self, textline):
        layout = QHBoxLayout(self)
        self.line_edit = textline
        self.include_objects.append(textline)
        layout.addWidget(self.line_edit)

    def setText(self, text):
        self.line_edit.setText(text)

    def getText(self):
        return self.line_edit.text()

    def setIcon(self, icon):
        from PySide6.QtGui import QIcon
        self.line_edit.setIcon(QIcon(icon))
        self.line_edit.setToolTip(self.line_edit.toolTip())

    def get_include_objects(self):
        return self.include_objects
///
/// filemanager.py
import sys
import os

import PyPDF2
import pandas as pd
import pdfplumber
from PySide6 import QtWidgets, QtCore, QtGui
from PySide6.QtCore import Signal
from PySide6.QtGui import QAction
from docx import Document

from utils.s2f import load_mdth_file


class CustomFileManager(QtWidgets.QWidget):
    file_selected = Signal(list)
    filepath_selected = Signal(str)

    def __init__(self, path: str = None, parent=None):
        super().__init__(parent)
        self.setWindowTitle('File Manager')

        # Основной макет
        layout = QtWidgets.QVBoxLayout(self)

        # Модель файловой системы
        self.model = QtWidgets.QFileSystemModel()
        self.model.setRootPath(QtCore.QDir.rootPath())

        # Дерево файловой системы
        self.tree = QtWidgets.QTreeView()
        self.tree.setModel(self.model)
        if path:
            self.tree.setRootIndex(self.model.index(path))
        self.tree.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)

        # Настройка отображения колонок
        self.tree.setColumnWidth(0, 250)
        self.tree.setColumnWidth(1, 100)
        self.tree.setColumnWidth(2, 100)
        self.tree.setColumnWidth(3, 150)

        # Контекстное меню
        self.tree.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.open_menu)
        self.tree.doubleClicked.connect(self.select_file)

        # Кнопки управления
        self.create_file_action = QAction("Create File", self)
        self.create_dir_action = QAction("Create Directory", self)
        self.delete_action = QAction("Delete", self)
        self.rename_action = QAction("Rename", self)

        # Слоты для кнопок
        self.create_file_action.triggered.connect(self.create_file)
        self.create_dir_action.triggered.connect(self.create_directory)
        self.delete_action.triggered.connect(self.delete_item)
        self.rename_action.triggered.connect(self.rename_item)

        # Добавление виджетов в макет
        layout.addWidget(self.tree)
        button_layout = QtWidgets.QHBoxLayout()
        layout.addLayout(button_layout)

    def select_file(self, index):
        file_path = self.model.filePath(index)
        if not os.path.isfile(file_path):
            return
        if file_path:
            self.filepath_selected.emit(file_path)
            data = []
            file_ext = file_path.lower()

            if file_ext.endswith('.mdth'):
                data = [{"mdth": load_mdth_file(file_path)}]
            elif file_ext.endswith(('.png', '.jpg', '.bmp')):
                data = [{'image_path': file_path}]
            elif file_ext.endswith('.csv'):
                data = pd.read_csv(file_path).to_dict(orient='records')
            elif file_ext.endswith('.xlsx') or file_ext.endswith('.xls'):
                data = pd.read_excel(file_path).to_dict(orient='records')
            elif file_ext.endswith('.docx'):
                doc = Document(file_path)
                data_temp = []
                for table in doc.tables:
                    table_data = []
                    for row in table.rows:
                        row_data = []
                        for cell in row.cells:
                            row_data.append(cell.text)
                        table_data.append(row_data)
                    data_temp.append(table_data)
                data = [{"dataword": data_temp}]

            elif file_ext.endswith('.pdf'):
                # Открываем PDF-файл с помощью pdfplumber
                with pdfplumber.open(file_path) as pdf:
                    for page in pdf.pages:
                        data.append(page.extract_text())
            else:
                with open(file_path, 'r') as f:
                    data = [line.strip() for line in f.readlines()]

            self.file_selected.emit(data)

    def open_menu(self, position):
        indexes = self.tree.selectedIndexes()
        if indexes:
            menu = QtWidgets.QMenu()
            menu.addAction(self.create_file_action)
            menu.addAction(self.create_dir_action)
            menu.addAction(self.delete_action)
            menu.addAction(self.rename_action)
            menu.exec_(self.tree.viewport().mapToGlobal(position))

    def create_file(self):
        index = self.tree.currentIndex()
        if not index.isValid():
            return

        dir_path = self.model.filePath(index)
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(self, "Create File", dir_path)
        if file_path:
            open(file_path, 'w').close()  # Создаем пустой файл

    def create_directory(self):
        index = self.tree.currentIndex()
        if not index.isValid():
            return

        dir_path = self.model.filePath(index)
        dir_name, ok = QtWidgets.QInputDialog.getText(self, "Create Directory", "Directory Name:")
        if ok and dir_name:
            os.mkdir(os.path.join(dir_path, dir_name))

    def delete_item(self):
        index = self.tree.currentIndex()
        if not index.isValid():
            return

        file_path = self.model.filePath(index)
        if os.path.isdir(file_path):
            os.rmdir(file_path)
        else:
            os.remove(file_path)

    def rename_item(self):
        index = self.tree.currentIndex()
        if not index.isValid():
            return

        file_path = self.model.filePath(index)
        new_name, ok = QtWidgets.QInputDialog.getText(self, "Rename Item", "New Name:")
        if ok and new_name:
            new_path = os.path.join(os.path.dirname(file_path), new_name)
            os.rename(file_path, new_path)

///
/// pyconsole.py
import os
import sys

from PySide6.QtGui import QTextCursor
from PySide6.QtWidgets import QApplication, QPlainTextEdit, QVBoxLayout, QWidget
from PySide6.QtCore import Qt, Signal
import code
import threading


class CustomPyConsole(QPlainTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle('Custom Console')
        self.setReadOnly(False)
        self.history = []
        self.number_of_lines = 0
        self.historyIndex = -1

        self.interpreter = code.InteractiveConsole(locals={})
        self.display_system_info()

    def display_system_info(self):
        system_info = (
            f"Version: {sys.version}\n"
            f"Name: {sys.thread_info}\n"
        )
        self.number_of_lines += 1
        self.prompt_style = f"{os.getcwd()} [{self.number_of_lines}]$ "
        self.number_of_lines += 1
        self.prompt_style = f"{os.getcwd()} [{self.number_of_lines}]$ "
        self.insertPlainText(system_info + self.prompt_style)


    def keyPressEvent(self, event):
        if event.key() in [Qt.Key_Return, Qt.Key_Enter]:
            cursor = self.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            line = cursor.block().text()[len(self.prompt_style):]
            self.history.append(line)
            self.historyIndex = -1
            self.run_command(line)
        elif event.key() == Qt.Key_Up:
            if self.history:
                self.historyIndex = (self.historyIndex - 1) % len(self.history)
                self.replace_current_line(self.history[self.historyIndex])
        elif event.key() == Qt.Key_Down:
            if self.history:
                self.historyIndex = (self.historyIndex + 1) % len(self.history)
                self.replace_current_line(self.history[self.historyIndex])
        else:
            super().keyPressEvent(event)

    def replace_current_line(self, text):
        cursor = self.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.StartOfLine)
        cursor.movePosition(QTextCursor.MoveOperation.EndOfLine, QTextCursor.MoveMode.KeepAnchor)
        cursor.removeSelectedText()
        cursor.insertText(self.prompt_style + text)

    def run_command(self, command):
        self.insertPlainText('\n')
        old_stdout = sys.stdout
        old_stderr = sys.stderr
        sys.stdout = self
        sys.stderr = self
        try:
            self.interpreter.push(command)
        finally:
            sys.stdout = old_stdout
            sys.stderr = old_stderr

        self.number_of_lines += 1
        self.prompt_style = f"{os.getcwd()} [{self.number_of_lines}]$ "
        self.insertPlainText(self.prompt_style)

    def write(self, text):
        self.insertPlainText(text)

    def flush(self):
        pass


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = QWidget()
    layout = QVBoxLayout()
    console = CustomPyConsole()
    layout.addWidget(console)
    window.setLayout(layout)
    window.setWindowTitle('PySide6 Console Widget')
    window.show()
    sys.exit(app.exec())

///
/// scrollcontainter.py
import json
import keyword
import re
import sys

from PySide6 import QtCore
from PySide6.QtCore import Qt, QEvent, Signal
from PySide6.QtGui import QIntValidator, QPixmap, QFont, QTextCursor, QTextCharFormat, QColor
from PySide6.QtWidgets import QWidget, QVBoxLayout, QScrollArea, QLabel, QFrame, QGridLayout, QLineEdit, \
    QTextEdit, QTableWidget, QTableWidgetItem, QMessageBox, QHeaderView, QPushButton

from utils.loaders import load_icon
from utils.s2f import save_to_word, save_to_excel, save_to_pdf, save_to_csv, save_to_json, save_to_html, save_to_txt, \
    save_to_xml


class CustomDataContainer(QWidget):
    get_textboxes = Signal(list)
    show_tests = Signal(list)

    def __init__(self, path, data: list = None, file_type: str = None, parent=None):
        super().__init__(parent)
        self.current_workspace = path
        self.is_show_block = False
        self.result_layout = None
        self.result_container = None
        self.icons = {
            'save_word': load_icon('./assets/save2/sword.png'),
            'save_excel': load_icon('./assets/save2/sexcel.png'),
            'save_pdf': load_icon('./assets/save2/spdf.png'),
            'save_csv': load_icon('./assets/save2/scsv.png'),
            'save_json': load_icon('./assets/save2/sjson.png'),
            'save_html': load_icon('./assets/save2/shtml.png'),
            'save_txt': load_icon('./assets/save2/stxt.png'),
            'save_xml': load_icon('./assets/save2/sxml.png'),
        }
        self.buttons_name = {
            'save_word': 'Сохранить как Word',
            'save_excel': 'Сохранить как Excel',
            'save_pdf': 'Сохранить как PDF',
            'save_csv': 'Сохранить как CSV',
            'save_json': 'Сохранить как JSON',
            'save_html': 'Сохранить как HTML',
            'save_txt': 'Сохранить как TXT',
            'save_xml': 'Сохранить как XML',
        }

        self.data = data if data else []
        self.result_data = []
        main_layout = QVBoxLayout(self)
        self.calculations = {}
        self.textboxes = []
        self.name_textboxes = []
        self.all_textboxes = []
        self.hidden_textboxes = []
        self.result_table = QTableWidget(self)
        self.scroll_area = QScrollArea(self)
        self.scroll_area.setWidgetResizable(True)

        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)

        if file_type == 'text':
            self.load_text_content(self.scroll_layout)
        elif file_type == 'image':
            self.load_image_content(self.scroll_layout)
        else:
            self.load_default_content(self.scroll_layout)

        self.scroll_area.setWidget(self.scroll_content)
        main_layout.addWidget(self.scroll_area)

        self.reset_button = QPushButton("Новый файл")
        self.reset_button.clicked.connect(self.reset)
        self.reset_button.setVisible(False)

        self.calculate_button = QPushButton("Начать расчет")
        self.calculate_button.clicked.connect(self.toggle_result_block)
        layout = QVBoxLayout(self)
        layout.addWidget(self.result_table)
        layout.addWidget(self.reset_button)
        widget = QFrame(self)
        widget.setLayout(layout)

        self.result_container = QFrame(self)
        self.result_container.setFrameShape(QFrame.StyledPanel)
        self.result_layout = QVBoxLayout(self.result_container)
        self.result_layout.setContentsMargins(10, 10, 10, 10)
        self.result_layout.setAlignment(Qt.AlignTop)
        self.result_table.setVisible(False)
        self.result_layout.addWidget(self.result_table)
        self.result_layout.addWidget(self.calculate_button)
        self.result_container.setLayout(self.result_layout)
        self.result_container.setVisible(False)

        # Connect signals for scrolling
        self.scroll_area.verticalScrollBar().valueChanged.connect(self.check_scroll_position)

        layout.addWidget(self.result_container)
        main_layout.addWidget(widget)

        self.callbacks = {
            'save_word': save_to_word,
            'save_excel': save_to_excel,
            'save_pdf': save_to_pdf,
            'save_csv': save_to_csv,
            'save_json': save_to_json,
            'save_html': save_to_html,
            'save_txt': save_to_txt,
            'save_xml': save_to_xml,
        }

    def save(self):
        sender = self.sender()
        self.check_main_dirs(self.current_workspace)
        try:
            event = sender.objectName()
            if event in self.callbacks:
                self.callbacks[event](path=self.current_workspace, data=self.data, textboxes=self.all_textboxes,
                                      result_data=self.result_data)
            else:
                QMessageBox.critical(self, 'Ошибка', "ErrorKey")
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', str(e))

    def check_main_dirs(self, path):
        import os
        if not os.path.exists(f"{path}/export"):
            os.mkdir(f"{path}/export")

    def reset(self):
        # QMESSAGE_BOX SAVE?
        self.data = []
        self.result_data = []
        self.textboxes = []
        self.name_textboxes = []
        self.all_textboxes = []
        self.hidden_textboxes = []
        self.result_table.setVisible(False)
        self.result_container.hide()
        self.is_show_block = False
        self.calculate_button.setVisible(True)
        self.reset_button.hide()
        self.result_table.hide()
        self.update_ui(True)
        self.scroll_area.verticalScrollBar().setValue(0)

    def check_scroll_position(self):
        scroll_bar = self.scroll_area.verticalScrollBar()
        max_scroll = scroll_bar.maximum()
        current_scroll = scroll_bar.value()
        try:
            if current_scroll >= max_scroll:
                if not self.is_show_block:
                    self.show_result_block()
                    self.is_show_block = True
            else:
                if current_scroll == 0:
                    self.is_show_block = False
                    self.hide_result()
        except Exception as e:
            print(e)

    def show_result_block(self):
        self.result_container.show()

    def toggle_result_block(self):
        if not self.result_table.isVisible():
            self.result_table.setVisible(True)
            self.update_data()
            self.calculate_button.hide()
            self.reset_button.setVisible(True)

    def update_data(self):
        self.update_result_data()

        self.result_table.setRowCount(len(self.result_data))
        self.result_table.setColumnCount(len(self.result_data[0]) if self.result_data else 0)
        for row, row_data in enumerate(self.result_data):
            for column, value in enumerate(row_data):
                item = QTableWidgetItem(str(value))
                item.setFlags(Qt.ItemIsEnabled)
                self.result_table.setItem(row, column, item)
        self.result_table.resizeColumnsToContents()

    def hide_result(self):
        self.result_container.hide()

    def evaluate_formula(self, components):
        """Evaluate a formula by replacing placeholders with actual values."""
        components = components.split('+')
        result = 0

        try:
            for component in components:
                component = component.strip()
                found = False

                for textbox in reversed(self.textboxes):
                    if textbox.objectName() == component:
                        value = int(textbox.text()) if textbox.text().isdigit() else 0
                        result += value
                        found = True
                        break

                if not found:
                    for hidden_textbox in reversed(self.hidden_textboxes):
                        if hidden_textbox.objectName() == component:
                            if not hidden_textbox.text():  # если значение пустое, вычислить его
                                formula = next(
                                    (calc["data"].split('=')[1] for row, calc in self.calculations.items() if
                                     calc["idx"] == component),
                                    None
                                )
                                if formula:
                                    hidden_textbox.setText(str(self.evaluate_formula(formula)))
                            value = int(hidden_textbox.text()) if hidden_textbox.text().isdigit() else 0
                            result += value
                            found = True
                            break

            return result
        except Exception as e:
            print(f"Error evaluating formula: {e}")
            return 0

    def update_result_data(self):
        self.result_data = []

        for row, item in self.calculations.items():
            row_data = []
            number = item["idx"]
            indicator = item["name"]
            row_data.append(number)
            row_data.append(indicator)

            if item["data"].startswith("(Автосумма)\n"):
                formula = item["data"].split('=')[1]
                result = self.evaluate_formula(formula)
                row_data.append(str(result) if result is not None else "Ошибка")

            self.result_data.append(row_data)

    def update_data_from_sender(self):
        if not self.data:
            print("No data available.")
            return

        mdth = self.data[0].get("mdth", None)

        if mdth is None:
            print("No 'mdth' data available.")
            return

        event = self.sender().objectName()
        for it in range(len(mdth)):
            if event in mdth[it]['idx']:
                mdth[it]['data'] = self.sender().text()
                break

    def on_text_changed(self):
        if not self.sender().objectName() in self.calculations.keys():
            self.update_data_from_sender()

        self.get_textboxes.emit(self.name_textboxes)

    def load_default_content(self, layout):
        if not self.data:
            return

        data_ptr = self.data[0].get("mdth", None)

        if not data_ptr:
            raise Exception("Не удалось получить данные")

        # int_validator = QIntValidator(self)
        grid_layout = QGridLayout()
        grid_layout.setColumnStretch(1, 1)

        for row, item in enumerate(data_ptr):
            number = item["idx"]
            indicator = item["name"]

            number_label = QLabel(number)
            indicator_label = QLabel(indicator)
            indicator_label.setWordWrap(True)

            grid_layout.addWidget(number_label, row, 0)
            grid_layout.addWidget(indicator_label, row, 1)

            answer_textbox = QLineEdit()
            self.all_textboxes.append(answer_textbox)
            answer_textbox.setObjectName(f"{number}")

            if item["data"].startswith("(Автосумма)\n"):
                answer_textbox.setDisabled(True)
                self.calculations[number] = item
                self.hidden_textboxes.append(answer_textbox)
                continue

            if item["data"] != " ":
                try:
                    _ = int(item["data"])
                except ValueError:
                    answer_textbox.setPlaceholderText(item["data"])
                else:
                    answer_textbox.setText(item["data"])
                # answer_textbox.setValidator(int_validator)
                answer_textbox.installEventFilter(self)
                answer_textbox.textChanged.connect(self.on_text_changed)
                self.name_textboxes.append([number_label, answer_textbox])
                self.textboxes.append(answer_textbox)

                grid_layout.addWidget(answer_textbox, row, 2)

        self.show_tests.emit(self.name_textboxes)
        layout.addLayout(grid_layout)

    def eventFilter(self, source, event):
        if not isinstance(event, QEvent):
            return False

        if event.type() == QtCore.QEvent.FocusIn:
            self.get_textboxes.emit(self.name_textboxes)

        if event.type() == QEvent.KeyPress and isinstance(source, QLineEdit):
            current_index = self.textboxes.index(source)

            def find_next_enabled_index(start_index, direction):
                index = start_index
                while True:
                    index = (index + direction) % len(self.textboxes)
                    if self.textboxes[index].isEnabled():
                        return index
                    if index == start_index:
                        return -1  # No enabled textbox found

            if event.key() in {Qt.Key_Return, Qt.Key_Enter, Qt.Key_Down}:
                next_index = find_next_enabled_index(current_index, 1)
                if next_index != -1:
                    self.textboxes[next_index].setFocus()
                    self.scroll_area.ensureWidgetVisible(self.textboxes[next_index])
                return True

            elif event.key() == Qt.Key_Up:
                previous_index = find_next_enabled_index(current_index, -1)
                if previous_index != -1:
                    self.textboxes[previous_index].setFocus()
                    self.scroll_area.ensureWidgetVisible(self.textboxes[previous_index])
                return True

        return super().eventFilter(source, event)

    def update_content(self, data):
        self.data = data
        self.update_ui()

    def get_data(self):
        if self.data:
            return self.data
        elif not self.data and hasattr(self, 'text_edit'):
            return self.text_edit.toPlainText()
        else:
            return None

    def update_ui(self, reset=False):
        for i in reversed(range(self.scroll_layout.count())):
            if isinstance(self.scroll_layout.itemAt(i), QGridLayout):
                for item in reversed(range(self.scroll_layout.itemAt(i).count())):
                    widget = self.scroll_layout.itemAt(i).itemAt(item).widget()
                    if widget:
                        widget.setParent(None)
            else:
                widget = self.scroll_layout.itemAt(i).widget()
                if widget:
                    widget.setParent(None)
        if reset:
            label = QLabel("Выберите или создайте новый файл")
            label.setFont(QFont("Arial", 16))
            self.scroll_layout.addWidget(label)
            return
        if not self.data:
            self.text_edit = QTextEdit()
            self.text_edit.setObjectName("base")
            self.text_edit.setReadOnly(False)
            self.text_edit.setFont(QFont("Arial", 12))
            self.text_edit.setStyleSheet(
                "QTextEdit { border: none; background-color: #f4f4f4; color: black; padding: 10px; }")
            self.scroll_layout.addWidget(self.text_edit)
            return

        if self.data and isinstance(self.data, list):
            if self.data[0] and isinstance(self.data[0], dict):
                first_key = next(iter(self.data[0].keys()))
                if first_key == 'image_path':
                    self.load_image_content(self.scroll_layout)
                elif first_key == 'mdth':
                    self.load_default_content(self.scroll_layout)
                else:
                    self.load_table_content(self.scroll_layout, self.data)
            else:
                self.load_text_content(self.scroll_layout)

    def load_text_content(self, layout):
        text_edit = QTextEdit()
        text_edit.setReadOnly(False)
        text_edit.setFont(QFont("Arial", 12))
        text_edit.setStyleSheet("QTextEdit { border: none; background-color: #f4f4f4; color: black; padding: 10px; }")

        # for item in self.data:
        #     if self.is_json(item):
        #         self.format_json(text_edit, item)
        #     elif self.is_xml(item):
        #         self.format_xml(text_edit, item)
        #     # elif self.is_python(item):
        #     #     self.format_python(text_edit, item)
        #     else:

        self.format_txt(text_edit, self.data)
        layout.addWidget(text_edit)

    def is_json(self, text):
        try:
            json.loads(text)
            return True
        except ValueError:
            return False

    def is_xml(self, text):
        import xml.etree.ElementTree as ET
        try:
            ET.fromstring(text)
            return True
        except ET.ParseError:
            return False

    # def is_python(self, text):
    #     try:
    #         compile(text, '<string>', 'exec')
    #         return True
    #     except SyntaxError:
    #         return False

    def format_json(self, text_edit, text):
        formatted_json = json.dumps(json.loads(text), indent=4)
        text_edit.append(formatted_json)

    def format_xml(self, text_edit, text):
        import xml.etree.ElementTree as ET
        try:
            tree = ET.ElementTree(ET.fromstring(text))
            formatted_xml = ET.tostring(tree.getroot(), encoding='unicode')
            text_edit.append(formatted_xml)
        except ET.ParseError as e:
            text_edit.append(f"Invalid XML: {str(e)}")

    # def format_python(self, text_edit, text):
    #     text_edit.setPlainText(text)
    #     cursor = text_edit.textCursor()
    #     cursor.select(QTextCursor.Document)
    #     cursor.setCharFormat(QTextCharFormat())
    #
    #     keywords_format = QTextCharFormat()
    #     keywords_format.setForeground(QColor("blue"))
    #     keywords_format.setFontWeight(QFont.Bold)
    #     keywords = keyword.kwlist
    #
    #     strings_format = QTextCharFormat()
    #     strings_format.setForeground(QColor("magenta"))
    #
    #     comments_format = QTextCharFormat()
    #     comments_format.setForeground(QColor("green"))
    #
    #     regex_keywords = r'\b(?:' + '|'.join(re.escape(word) for word in keywords) + r')\b'
    #     regex_strings = r'"[^"\\]*(\\.[^"\\]*)*"|\'[^\'\\]*(\\.[^\'\\]*)*\''
    #     regex_comments = r'#.*'
    #
    #     cursor.movePosition(QTextCursor.Start)
    #     while not cursor.atEnd():
    #         cursor.movePosition(QTextCursor.EndOfBlock, QTextCursor.KeepAnchor)
    #         line = cursor.selectedText()
    #
    #         for match in re.finditer(regex_keywords, line):
    #             cursor.setPosition(cursor.selectionStart() + match.start())
    #             cursor.setPosition(cursor.selectionStart() + match.end(), QTextCursor.KeepAnchor)
    #             cursor.setCharFormat(keywords_format)
    #
    #         for match in re.finditer(regex_strings, line):
    #             cursor.setPosition(cursor.selectionStart() + match.start())
    #             cursor.setPosition(cursor.selectionStart() + match.end(), QTextCursor.KeepAnchor)
    #             cursor.setCharFormat(strings_format)
    #
    #         for match in re.finditer(regex_comments, line):
    #             cursor.setPosition(cursor.selectionStart() + match.start())
    #             cursor.setPosition(cursor.selectionStart() + match.end(), QTextCursor.KeepAnchor)
    #             cursor.setCharFormat(comments_format)
    #
    #         cursor.movePosition(QTextCursor.NextBlock)

    def format_txt(self, text_edit, text):
        for item in text:
            if isinstance(item, list):
                for subitem in item:
                    text_edit += str(subitem)
            text_edit.append(item)

    def load_image_content(self, layout):
        for item in self.data:
            image_label = QLabel()
            pixmap = QPixmap(item.get('image_path', ''))
            if not pixmap.isNull():
                image_label.setPixmap(pixmap.scaledToWidth(400))  # Adjust width as needed
                image_label.setAlignment(Qt.AlignCenter)
                image_label.setStyleSheet("QLabel { margin: 10px; }")
                layout.addWidget(image_label)

    def load_table_content(self, layout, data):
        if data and data[0].get('dataword', None):
            for table_data in data[0].get('dataword', None):
                table_widget = QTableWidget()
                headers = table_data[1]  # Assuming the first row is the header
                table_widget.setColumnCount(len(headers))
                table_widget.setHorizontalHeaderLabels(headers)
                table_widget.setRowCount(len(table_data) - 1)  # Number of data rows excluding header
                table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
                table_widget.setFont(QFont("Arial", 10))
                table_widget.setStyleSheet(
                    "QTableWidget { background-color: #f4f4f4; color: black; border: none; } "
                    "QHeaderView::section { background-color: #d4d4d4; color: black; padding: 5px; border: none; } "
                    "QTableWidget::item { padding: 5px; color: black;}"
                )

                for row_idx, row_data in enumerate(table_data[2:], 1):  # Start from index 1 to skip header
                    for col_idx, col_value in enumerate(row_data):
                        item = QTableWidgetItem(str(col_value))
                        item.setFlags(Qt.ItemIsEnabled)
                        table_widget.setItem(row_idx - 1, col_idx, item)  # row_idx - 1 because of skipping header

                layout.addWidget(table_widget)
            return
        if data:
            table_widget = QTableWidget()
            for row_idx, row_data in enumerate(data):
                headers = row_data.keys()
                table_widget.setColumnCount(len(headers))
                table_widget.setHorizontalHeaderLabels(headers)
                table_widget.setRowCount(len(data))

                table_widget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
                table_widget.setFont(QFont("Arial", 10))
                table_widget.setStyleSheet(
                    "QTableWidget { background-color: #f4f4f4; color: black; border: none; } QHeaderView::section { background-color: #d4d4d4; padding: 5px; border: none; } QTableWidget::item { padding: 5px; }")
                for col_idx, (col_name, col_value) in enumerate(row_data.items()):
                    item = QTableWidgetItem(str(col_value))
                    item.setFlags(Qt.ItemIsEnabled)
                    table_widget.setItem(row_idx, col_idx, item)

///
/// testwidget.py
from PySide6 import QtWidgets
from PySide6.QtCore import Qt, Slot
from PySide6.QtGui import QIcon
from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QListWidget, QListWidgetItem, QLabel, QTableWidget, \
    QAbstractItemView, QTableWidgetItem, QLineEdit
from gui.widgets.customwidgetitem import CustomWidgetItem


class CustomTestWidget(QWidget):
    def __init__(self, test_names=None, icons=None, parent=None):
        super().__init__(parent)
        if icons is None:
            icons = []

        if test_names is None:
            test_names = []

        self.tests = test_names
        self.icons = icons
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout(self)
        self.table_widget = QTableWidget()
        self.table_widget.setColumnCount(1)  # 3 columns: Icon, Test, Hidden Data
        self.table_widget.setHorizontalHeaderLabels(['Questions'])
        self.table_widget.horizontalHeader().setStretchLastSection(True)
        self.table_widget.verticalHeader().setVisible(False)
        self.table_widget.setSelectionMode(QAbstractItemView.NoSelection)
        self.table_widget.setEditTriggers(QAbstractItemView.NoEditTriggers)

        layout.addWidget(self.table_widget)

        self.test_items = []

        for name in self.test_items:
            self.addTestItem(name)

    def addTestItem(self, name):
        row_position = self.table_widget.rowCount()
        self.table_widget.insertRow(row_position)

        text_item = QTableWidgetItem()
        text_item.setText(name.text())
        text_item.setIcon(QIcon(self.icons[1]))
        self.table_widget.setItem(row_position, 0, text_item)

    def loadTests(self, tests: list):
        self.table_widget.setRowCount(0)  # Clear existing rows
        self.test_items = tests
        for name, _ in self.test_items:
            self.addTestItem(name)

    @Slot(list)
    def updateIcons(self, data):
        label_to_textbox_map = {label.text(): textbox for label, textbox in data}
        for row in range(self.table_widget.rowCount()):
            icon_item = self.table_widget.item(row, 0)
            if icon_item.text() in label_to_textbox_map:
                if self.is_test_done(label_to_textbox_map[icon_item.text()]):
                    icon_item.setIcon(QIcon(self.icons[0]))  # Done icon
                elif self.is_test_in_progress(label_to_textbox_map[icon_item.text()]):
                    icon_item.setIcon(QIcon(self.icons[2]))  # Not done icon
                else:
                    icon_item.setIcon(QIcon(self.icons[1]))  # In-progress icon

    def is_test_done(self, test_name: QLineEdit):
        if test_name:
            return test_name.text() != ''

    def is_test_in_progress(self, test_name: QLineEdit):
        if test_name:
            return test_name.hasFocus()

///

/// main_window.py
import os
import subprocess
import sys

from PySide6 import QtWidgets, QtCore, QtGui
from PySide6.QtGui import QAction, Qt
from PySide6.QtWidgets import QVBoxLayout, QPushButton, QWidget, QSplitter, QFrame, QHBoxLayout, QFileDialog, \
    QMessageBox, QMenuBar, QLabel

from gui.widgets.bashconsole import CustomBashConsole
from gui.widgets.filemanager import CustomFileManager
from gui.widgets.pyconsole import CustomPyConsole
from gui.widgets.scrollcontainter import CustomDataContainer
from gui.widgets.testwidget import CustomTestWidget
from utils.loaders import load_icon


class Ui_MainWindow(QtWidgets.QMainWindow):
    """
    Main window class
    """
    position_widgets = {
        "main_container": [0, 1, 2, 1],
        "right_toolbar": [0, 2, 2, 1],
        "left_toolbar": [0, 0],
    }

    def __init__(self, parent: QtWidgets.QWidget = None, *args, **kwargs) -> None:
        """
        Initialize the main window
        """
        super(Ui_MainWindow, self).__init__(parent)
        self.splitter = None
        self.left_container = None
        self.current_workspace = kwargs.get("path")
        self.bash_console = None
        self.pyconsole = None
        self.splitter_console = None
        self.right_toolbar_container = None
        self.left_toolbar_container = None
        self.file_widget = None
        self.container = None
        self.left_toolbar_layout = None
        self.current_icon_state = None
        self.button_hide_file_widget = None
        self.right_toolbar_layout = None
        self.gridLayout = None
        self.centralwidget = None
        self.assets_path = "./assets"

        self.icons = {
            'hidden_folder': load_icon('./assets/folder/hidden_folder.png'),
            'open_clear_folder': load_icon('./assets/folder/open_clear_folder.png'),
            'open_full_folder': load_icon('./assets/folder/open_full_folder.png'),
            'bash': load_icon('./assets/console/bash.png'),
            'py': load_icon('./assets/console/py.png'),
            'test_btn': load_icon('./assets/test/button.png'),
            'success_question': load_icon('./assets/test/qs.png'),
            'failed_question': load_icon('./assets/test/qc.png'),
            'process_question': load_icon('./assets/test/qp.png'),
            'menu_exit': load_icon('./assets/main/menu_exit.png'),
            'menu_file': load_icon('./assets/main/menu_file.png'),
            'menu_new': load_icon('./assets/main/menu_new.png'),
            'menu_new_file': load_icon('./assets/main/menu_new_file.png'),
            'menu_new_project': load_icon('./assets/main/menu_new_project.png'),
            'menu_open': load_icon('./assets/main/menu_open.png'),
            'menu_open_file': load_icon('./assets/main/menu_open_file.png'),
            'menu_open_project': load_icon('./assets/main/menu_open_project.png'),
            'menu_save': load_icon('./assets/main/menu_save.png'),
            'menu_save_as': load_icon('./assets/main/menu_save_as.png'),
            'menu_txt': load_icon('./assets/main/menu_txt.png'),
            'main_menu': load_icon('./assets/main/main_menu.png'),

        }

        self.saves_icons = {
            'save_word': load_icon('./assets/save2/sword.png'),
            'save_excel': load_icon('./assets/save2/sexcel.png'),
            'save_pdf': load_icon('./assets/save2/spdf.png'),
            'save_csv': load_icon('./assets/save2/scsv.png'),
            'save_json': load_icon('./assets/save2/sjson.png'),
            'save_html': load_icon('./assets/save2/shtml.png'),
            'save_txt': load_icon('./assets/save2/stxt.png'),
            'save_xml': load_icon('./assets/save2/sxml.png'),
        }
        self.buttons_name = {
            'save_word': 'Сохранить как Word',
            'save_excel': 'Сохранить как Excel',
            'save_pdf': 'Сохранить как PDF',
            'save_csv': 'Сохранить как CSV',
            'save_json': 'Сохранить как JSON',
            'save_html': 'Сохранить как HTML',
            'save_txt': 'Сохранить как TXT',
            'save_xml': 'Сохранить как XML',
        }
        self.current_open_file = ''
        self.setupUi(self, *args, **kwargs)

    def setupUi(self, _MainWindow: QtWidgets.QMainWindow, *args, **kwargs) -> None:
        _MainWindow.setObjectName("MainWindow")
        _MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(_MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.container = self.setupUiMainFrame()
        self.bash_console = CustomBashConsole(self.container)

        python_installed = self.check_python_installed()

        if python_installed:
            self.pyconsole = CustomPyConsole(self.container)
            self.pyconsole.setVisible(False)
        else:
            self.pyconsole = None
            QMessageBox.warning(self, "Python is not installed",
                                "Python не обнаружен, некоторый функционал ограничен.\n\n")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setSpacing(0)

        self.centralwidget.setLayout(self.gridLayout)
        _MainWindow.setCentralWidget(self.centralwidget)

        # Create a splitter to divide containers
        self.splitter = QSplitter(QtCore.Qt.Horizontal)
        self.splitter.setHandleWidth(1)
        self.splitter.setStyleSheet("""
              QSplitter::handle {
                  background: lightgray;
              }
          """)

        # Create left container that includes the file manager and left toolbar
        self.left_container = QWidget()
        self.left_layout = QHBoxLayout(self.left_container)
        self.left_layout.setContentsMargins(0, 0, 0, 0)
        self.left_layout.setSpacing(0)

        # Left toolbar with buttons
        self.left_toolbar_container = QFrame(self.left_container)
        self.left_toolbar_container.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.left_toolbar_container.setFixedWidth(50)
        self.left_toolbar_container.setMaximumWidth(50)

        self.left_toolbar_layout = QVBoxLayout(self.left_toolbar_container)
        self.left_toolbar_layout.setContentsMargins(0, 0, 0, 0)
        self.left_toolbar_layout.setSpacing(0)
        self.left_toolbar_layout.setAlignment(QtCore.Qt.AlignTop)

        # Buttons for toggling visibility
        self.button_hide_file_widget = QPushButton()
        self.button_hide_file_widget.setFixedSize(50, 40)
        self.button_hide_file_widget.clicked.connect(self.toggle_file_widget_visibility)
        self.button_hide_file_widget.setToolTip("Toggle File Widget")

        self.button_bash = QPushButton(icon=self.icons.get('bash'))
        self.button_bash.setFixedSize(50, 40)
        self.button_bash.clicked.connect(self.toggle_bash_widget_visibility)
        self.button_bash.setToolTip("Toggle Bash Console")

        self.button_pyconsole = QPushButton(icon=self.icons.get('py'))
        self.button_pyconsole.setFixedSize(50, 40)
        self.button_pyconsole.clicked.connect(self.toggle_pyconsole_widget_visibility)
        self.button_pyconsole.setToolTip("Toggle Python Console")

        self.button_test = QPushButton(icon=self.icons.get('test_btn'))
        self.button_test.setFixedSize(50, 40)
        self.button_test.clicked.connect(self.toggle_tests_widget_visibility)
        self.button_test.setToolTip("Toggle tests")

        if not python_installed:
            self.button_pyconsole.setEnabled(False)

        # Add buttons to the toolbar layout
        self.left_toolbar_layout.addWidget(self.button_hide_file_widget)
        self.left_toolbar_layout.addWidget(self.button_bash)
        self.left_toolbar_layout.addWidget(self.button_pyconsole)
        self.left_toolbar_layout.addWidget(self.button_test)

        # Create splitter for CustomFileManager and CustomTestWidget
        self.left_toolbar_splitter = QSplitter(QtCore.Qt.Vertical)
        self.test_widget = CustomTestWidget(icons=[self.icons.get('success_question'),
                                             self.icons.get('failed_question'),
                                             self.icons.get('process_question')],
                                      parent=self.left_container)

        self.container.get_textboxes.connect(self.test_widget.updateIcons)
        self.container.show_tests.connect(self.test_widget.loadTests)
        self.file_widget = CustomFileManager(kwargs.get('path'), _MainWindow)
        self.file_widget.file_selected.connect(self.container.update_content)
        self.file_widget.filepath_selected.connect(self.update_current_open_file)

        # Add CustomFileManager and CustomTestWidget to the splitter
        self.left_toolbar_splitter.addWidget(self.file_widget)
        self.left_toolbar_splitter.addWidget(self.test_widget)

        # Add splitter and left toolbar container to the left layout
        self.left_layout.addWidget(self.left_toolbar_container)
        self.left_layout.addWidget(self.left_toolbar_splitter)

        self.right_container = QWidget()
        self.right_layout = QHBoxLayout(self.right_container)
        self.right_layout.setContentsMargins(0, 0, 0, 0)
        self.right_layout.setSpacing(0)

        self.right_toolbar_container = QFrame(self.right_container)
        self.right_toolbar_container.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.right_toolbar_layout = QVBoxLayout(self.right_toolbar_container)
        self.right_toolbar_layout.setContentsMargins(0, 0, 0, 0)
        self.right_toolbar_layout.setSpacing(0)
        self.right_toolbar_layout.setAlignment(QtCore.Qt.AlignTop)
        self.right_toolbar_container.setFixedWidth(60)

        self.right_layout.addWidget(self.container)
        self.right_layout.addWidget(self.right_toolbar_container)

        self.splitter.addWidget(self.left_container)
        self.splitter.addWidget(self.right_container)
        self.splitter.setSizes([int(0.20 * self.splitter.width()), int(0.80 * self.splitter.width())])
        self.add_initial_buttons()
        self.current_icon_state = "closed"
        self.update_button_icon()

        # Create a separate splitter for the consoles
        self.splitter_console = QSplitter(QtCore.Qt.Horizontal)
        self.splitter_console.addWidget(self.bash_console)
        if python_installed:
            self.splitter_console.addWidget(self.pyconsole)

        console_widget = QWidget()
        console_layout = QHBoxLayout(console_widget)
        console_layout.setContentsMargins(0, 0, 0, 0)
        console_layout.setSpacing(0)
        console_layout.addWidget(self.splitter_console)
        console_widget.setLayout(console_layout)

        # Create a vertical splitter that contains both the main content and the consoles
        self.splitter_block = QSplitter(QtCore.Qt.Vertical)
        self.splitter_block.addWidget(self.splitter)
        self.splitter_block.addWidget(console_widget)

        self.gridLayout.addWidget(self.splitter_block, 0, 0, 1, 1)

        self.adjust_container_sizes_()

        menu_bar = self.setupUiMenu()
        _MainWindow.setMenuBar(menu_bar)
        _MainWindow.setWindowTitle("Main Window")

    def check_python_installed(self):
        try:
            subprocess.check_output(['python', '--version'])
            return True
        except subprocess.CalledProcessError:
            return False
        except FileNotFoundError:
            return False

    def setupUiMenu(self) -> QtWidgets.QMenuBar:
        """
        Setup the main window menu
        :return: QtWidgets.QMenuBar
        """

        def configure_menu(menubar: QtWidgets.QMenuBar) -> None:
            new_menu = QtWidgets.QMenu("New", self)
            new_menu.setIcon(self.icons.get('menu_new'))
            new_file_action = QAction(text="New File", icon=self.icons.get('menu_new_file'), parent=self)
            new_file_action.triggered.connect(self.new_file)
            new_project_action = QAction(text="New Project", icon=self.icons.get('menu_new_project'), parent=self)
            new_project_action.triggered.connect(self.new_project)

            if self.pyconsole:
                new_python_action = QAction(text="New Python File", icon=self.icons.get('py'), parent=self)
                new_python_action.triggered.connect(self.new_python_file)

            new_plain_text_action = QAction(text="New Plain Text", icon=self.icons.get('menu_txt'), parent=self)
            new_plain_text_action.triggered.connect(self.new_plain_text)
            new_menu.addAction(new_file_action)
            new_menu.addAction(new_project_action)
            new_menu.addSeparator()
            new_menu.addAction(new_python_action)
            new_menu.addAction(new_plain_text_action)

            # Open submenu
            open_menu = QtWidgets.QMenu("Open", self)
            open_menu.setIcon(self.icons.get('menu_open'))
            open_file_action = QAction(text="Open File", icon=self.icons.get('menu_file'), parent=self)
            open_file_action.triggered.connect(self.open_file)
            open_project_action = QAction(text="Open Project", icon=self.icons.get('menu_open_project'), parent=self)
            open_project_action.triggered.connect(self.open_project)
            open_menu.addAction(open_file_action)
            open_menu.addAction(open_project_action)

            save_menu = QtWidgets.QMenu("Save As", self)
            save_menu.setIcon(self.icons.get('menu_save_as'))
            save_to_word_action = QAction(text="docx", icon=self.saves_icons['save_word'], parent=self)
            save_to_word_action.setObjectName("save_to_word")
            save_to_word_action.triggered.connect(self.container.save)

            save_to_excel_action = QAction(text="xlsx", icon=self.saves_icons['save_excel'], parent=self)
            save_to_excel_action.setObjectName("save_to_excel")
            save_to_excel_action.triggered.connect(self.container.save)

            save_to_pdf_action = QAction(text="pdf", icon=self.saves_icons['save_pdf'], parent=self)
            save_to_pdf_action.setObjectName("save_to_pdf")
            save_to_pdf_action.triggered.connect(self.container.save)

            save_to_csv_action = QAction(text="csv", icon=self.saves_icons['save_csv'], parent=self)
            save_to_csv_action.setObjectName("save_to_csv")
            save_to_csv_action.triggered.connect(self.container.save)

            save_to_json_action = QAction(text="json", icon=self.saves_icons['save_json'], parent=self)
            save_to_json_action.setObjectName("save_to_json")
            save_to_json_action.triggered.connect(self.container.save)

            save_to_html_action = QAction(text="html", icon=self.saves_icons['save_html'], parent=self)
            save_to_html_action.setObjectName("save_to_html")
            save_to_html_action.triggered.connect(self.container.save)

            save_to_xml_action = QAction(text="xml", icon=self.saves_icons['save_xml'], parent=self)
            save_to_xml_action.setObjectName("save_to_xml")
            save_to_xml_action.triggered.connect(self.container.save)

            save_to_txt_action = QAction(text="txt", icon=self.saves_icons['save_txt'], parent=self)
            save_to_txt_action.setObjectName("save_to_txt")
            save_to_txt_action.triggered.connect(self.container.save)

            save_menu.addAction(save_to_word_action)
            save_menu.addAction(save_to_excel_action)
            save_menu.addAction(save_to_pdf_action)
            save_menu.addAction(save_to_csv_action)
            save_menu.addAction(save_to_json_action)
            save_menu.addAction(save_to_html_action)
            save_menu.addAction(save_to_xml_action)
            save_menu.addAction(save_to_txt_action)

            file_menu = menubar.addMenu("File")
            file_menu.setFixedWidth(150)
            file_menu.setIcon(self.icons.get('menu_file'))
            file_menu.addMenu(new_menu)
            file_menu.addMenu(open_menu)
            save_action = QAction(text="Save", icon=self.icons.get('menu_save'), parent=self)
            save_action.triggered.connect(self.save_file)
            file_menu.addAction(save_action)

            file_menu.addMenu(save_menu)
            file_menu.addSeparator()
            exit_action = QAction(text="Exit", icon=self.icons.get('menu_exit'), parent=self)
            exit_action.triggered.connect(self.close)
            file_menu.addAction(exit_action)
            file_menu.setIcon(self.icons.get('main_menu'))

            projects_menu = menubar.addMenu(os.path.basename(self.current_workspace))
            open_project_action = QAction(text="Open...", icon=self.icons.get('menu_open'), parent=self)
            open_project_action.triggered.connect(self.open_file_explorer)
            projects_menu.addAction(open_project_action)

            projects_menu.addSeparator()

            current_project_action = QAction(text=os.path.basename(self.current_workspace),
                                             icon=self.icons.get('menu_open'), parent=self)
            current_project_action.triggered.connect(lambda: self.open_project(self.current_workspace))
            projects_menu.addAction(current_project_action)

            current_project_path_action = QAction(text=self.current_workspace, parent=self)
            current_project_path_action.setEnabled(False)
            projects_menu.addAction(current_project_path_action)

            projects_menu.addSeparator()

            # Add recent projects
            # existing_projects = ["D:\\project\\proj-01", "D:\\project\\proj-02"]
            # for project_path in existing_projects:
            #     project_name = os.path.basename(project_path)
            #     project_action = QAction(project_name, self)
            #     project_action.triggered.connect(lambda checked, path=project_path: self.open_project(path))
            #     projects_menu.addAction(project_action)

            # Styling for the projects menu
            projects_menu.setStyleSheet("""
                QMenu {
                    background-color: #2e2e2e;
                    color: #ffffff;
                    border: 1px solid #1e1e1e;
                }
                QMenu::item {
                    color: #7097ba;
                }
                QMenu::separator {
                    height: 1px;
                    background: #4e4e4e;
                    margin-left: 10px;
                    margin-right: 5px;
                }
            """)

        self.menubar = QMenuBar(self)
        self.menubar.setObjectName("menubar")

        configure_menu(self.menubar)

        self.file_path_label = QLabel(f"{os.path.basename(self.current_open_file)} [{self.current_workspace}]")
        self.file_path_label.setObjectName("file_path_label")
        self.file_path_label.setStyleSheet("color: #7097ba")
        self.file_path_label.setFixedWidth(
            QLabel(f"{os.path.basename(self.current_open_file)} [{self.current_workspace}]").width())
        self.file_path_label.setAlignment(Qt.AlignCenter)
        self.menubar.setCornerWidget(self.file_path_label, Qt.Corner.TopRightCorner)

        return self.menubar

    def open_file_explorer(self, path=None):
        if not path:
            path = self.current_workspace
        print(f"Opening file explorer with path:  {path}")
        if not os.path.exists(path):
            print(f"Path does not exist: {path}")
            return

        try:
            if sys.platform.startswith('win'):
                print(f"Opening explorer with path: {path}")
                subprocess.Popen(['explorer', path], shell=True)
            elif sys.platform.startswith('linux'):
                print(f"Opening xdg-open with path: {path}")
                subprocess.Popen(['xdg-open', path], shell=True)
            else:
                raise NotImplementedError("Unsupported operating system")
        except Exception as e:
            print(f"Failed to open file explorer: {e}")

    def setupUiMainFrame(self) -> QWidget:
        """
         Setup the main frame of the main window .
        :return: QWidget
        """
        container = CustomDataContainer(self.current_workspace)
        container.setObjectName("MainContainer")
        return container

    def setupUiStatusBar(self, _MainWindow: QtWidgets.QStatusBar) -> None:
        pass

    def update_current_open_file(self, filepath):
        self.current_open_file = filepath
        self.file_path_label.setText(f"{os.path.basename(self.current_open_file)} [{self.current_workspace}]")

        self.file_path_label.setFixedWidth(
            QLabel(f"{os.path.basename(self.current_open_file)} [{self.current_workspace}]").width())

    def keyPressEvent(self, event):
        if event.modifiers() & Qt.ControlModifier and event.key() == Qt.Key_S:
            self.save_file()
        else:
            super().keyPressEvent(event)

    def closeEvent(self, event):
        self.save_file()
        event.accept()

    def save_file(self):
        file_path = self.current_open_file
        if not file_path:
            return

        if file_path.endswith(".mdth"):
            import json
            try:
                data = self.container.get_data()[0].get('mdth')
                with open(self.current_open_file, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False, indent=4)
                print("Data saved successfully.")
            except Exception as e:
                print(f"Failed to save data: {e}")
            return
        if file_path.endswith((".txt", ".py", ".json")):
            with open(file_path, 'w') as f:
                text = self.container.get_data()
                if not text:
                    QMessageBox.information(self, "File saved failed", "File not is saved, please save it manually")
                f.write(text)
            return
        else:
            QMessageBox.information(self, "File saved failed", "File type is not supported")

    def toggle_file_widget_visibility(self):
        file_widget = self.file_widget
        if file_widget:
            file_visible = not file_widget.isVisible()
            file_widget.setVisible(file_visible)
            self.adjust_container_sizes()

    def toggle_tests_widget_visibility(self):
        file_widget = self.test_widget
        if file_widget:
            file_visible = not file_widget.isVisible()
            file_widget.setVisible(file_visible)
            self.adjust_container_sizes()

    def toggle_bash_widget_visibility(self):
        file_widget = self.bash_console
        if file_widget:
            file_visible = not file_widget.isVisible()
            file_widget.setVisible(file_visible)
            self.adjust_container_sizes_()

    def toggle_pyconsole_widget_visibility(self):
        file_widget = self.pyconsole
        if file_widget:
            file_visible = not file_widget.isVisible()
            file_widget.setVisible(file_visible)
            self.adjust_container_sizes_()

    def adjust_container_sizes_(self):
        if self.pyconsole:
            if self.bash_console.isVisible() and self.pyconsole.isVisible():
                self.splitter_console.setSizes(
                    [int(0.5 * self.splitter_console.width()), int(0.5 * self.splitter_console.width())])
                self.splitter_block.setSizes(
                    [int(0.7 * self.splitter_console.width()), int(0.3 * self.splitter_console.width())])
            elif self.bash_console.isVisible():
                self.splitter_console.setSizes([int(1.0 * self.splitter_console.width()), 0])
                self.splitter_block.setSizes(
                    [int(0.7 * self.splitter_console.width()), int(0.3 * self.splitter_console.width())])
            elif self.pyconsole.isVisible():
                self.splitter_console.setSizes([0, int(1.0 * self.splitter_console.width())])
                self.splitter_block.setSizes(
                    [int(0.7 * self.splitter_console.width()), int(0.3 * self.splitter_console.width())])
            else:
                self.splitter_console.setSizes([0, 0])
                self.splitter_block.setSizes([int(1.0 * self.splitter_console.width()), 0])
        else:
            if self.bash_console.isVisible():
                self.splitter_console.setSizes(
                    [int(0.5 * self.splitter_console.width()), int(0.5 * self.splitter_console.width())])
                self.splitter_block.setSizes(
                    [int(0.7 * self.splitter_console.width()), int(0.3 * self.splitter_console.width())])
            elif self.bash_console.isVisible():
                self.splitter_console.setSizes([int(1.0 * self.splitter_console.width()), 0])
                self.splitter_block.setSizes(
                    [int(0.7 * self.splitter_console.width()), int(0.3 * self.splitter_console.width())])
            else:
                self.splitter_console.setSizes([0, 0])
                self.splitter_block.setSizes([int(1.0 * self.splitter_console.width()), 0])

    def adjust_container_sizes(self):
        if not self.file_widget.isVisible() and not self.test_widget.isVisible():
            self.splitter.setSizes([int(0.02 * self.splitter.width()), int(0.95 * self.splitter.width())])
        else:
            self.splitter.setSizes([int(0.20 * self.splitter.width()), int(0.80 * self.splitter.width())])

    def update_button_icon(self):
        """
        Update button icon based on current state
        """
        if self.current_icon_state == "closed":
            self.button_hide_file_widget.setIcon(self.icons["hidden_folder"])
        elif self.current_icon_state == "opened":
            self.button_hide_file_widget.setIcon(self.icons["open_full_folder"])
        elif self.current_icon_state == "empty_directory":
            self.button_hide_file_widget.setIcon(self.icons["open_clear_folder"])
        else:
            self.button_hide_file_widget.setIcon(QtGui.QIcon())  # Default icon if state not recognized

    def add_initial_buttons(self):
        buttons = []
        for it, (key, icon) in enumerate(self.saves_icons.items()):
            button = QPushButton(icon, "")
            button.setObjectName(key)
            button.setFixedSize(50, 40)
            button.setSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
            button.clicked.connect(self.container.save)
            button.setToolTip(self.buttons_name.get(key))  # Set tooltip with the button name
            buttons.append(button)

            if len(buttons) <= 3:
                self.right_toolbar_layout.addWidget(button)

        if len(buttons) > 3:
            menu_button = QPushButton("...", self.right_toolbar_container)
            menu_button.setFixedSize(50, 40)
            menu_button.setSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
            self.right_toolbar_layout.addWidget(menu_button)

            menu = QtWidgets.QMenu(self)
            for button in buttons[3:]:
                action = menu.addAction(button.icon(), self.buttons_name.get(button.objectName()))
                action.setObjectName(button.objectName())
                action.triggered.connect(self.container.save)

            menu_button.setMenu(menu)

    def new_file(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(self, "Create New File", "", "All Files (*.mdth)", options=options)
        if file_path:
            try:
                import json
                with open("configuration_config_mdt.json", "r", encoding="utf-8") as file:
                    data = json.load(file)

                from utils.s2f import generate_mdth_file

                if sys.platform.startswith("win"):
                    generate_mdth_file(data, file_path)
                if sys.platform.startswith("lin"):
                    generate_mdth_file(data, file_path + ".mdth")

                QMessageBox.information(self, "Success", f"New file created: {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to create file: {str(e)}")

    def new_project(self):
        QMessageBox.information(self, "Warning", "This function is currently not implemented, added in the future")

        # options = QFileDialog.Options()
        # directory_path = QFileDialog.getExistingDirectory(self, "Create New Project", options=options)
        # if directory_path:
        #     try:
        #         os.makedirs(directory_path, exist_ok=True)
        #         QMessageBox.information(self, "Success", f"New project created: {directory_path}")
        #     except Exception as e:
        #         QMessageBox.critical(self, "Error", f"Failed to create project: {str(e)}")

    def new_python_file(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(self, "Create New Python File", "", "Python Files (*.py)",
                                                   options=options)
        if file_path:
            try:
                with open(file_path, 'w') as file:
                    file.write('')
                QMessageBox.information(self, "Success", f"New Python file created: {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to create Python file: {str(e)}")

    def new_plain_text(self):
        options = QFileDialog.Options()
        file_path, _ = QFileDialog.getSaveFileName(self, "Create New Plain Text File", "", "Text Files (*.txt)",
                                                   options=options)
        if file_path:
            try:
                with open(file_path, 'w') as file:
                    file.write('')
                QMessageBox.information(self, "Success", f"New plain text file created: {file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to create plain text file: {str(e)}")

    def open_file(self):
        QMessageBox.information(self, "Warning", "This function is currently not implemented, added in the future")

        # options = QFileDialog.Options()
        # file_path, _ = QFileDialog.getOpenFileName(self, "Open File", "", "All Files (*)", options=options)
        # if file_path:
        #     try:
        #         import json
        #         with open("configuration_config_mdt.json", "r", encoding="utf-8") as file:
        #             data = json.load(file)
        #
        #         from utils.s2f import generate_mdth_file
        #
        #         if sys.platform.startswith("win"):
        #             generate_mdth_file(data, file_path)
        #         if sys.platform.startswith("lin"):
        #             generate_mdth_file(data, file_path + ".mdth")
        #
        #         QMessageBox.information(self, "Success", f"New file created: {file_path}")
        #     except Exception as e:
        #         QMessageBox.critical(self, "Error", f"Failed to create file: {str(e)}")

    def open_project(self):
        QMessageBox.information(self,  "Warning", "This function is currently not implemented, added in the future")

        # directory_path = QtWidgets.QFileDialog.getExistingDirectory(self, "Выбрать директорию проекта для открытия")
        # if directory_path:
        #     projmd_file = os.path.join(directory_path, "proj.projmd")
        #     if os.path.isfile(projmd_file):
        #         import json
        #         with open(projmd_file, 'r') as f:
        #             project_data = json.load(f)
        #             self.current_workspace = project_data["directory"]
        #             self.reset(self.current_workspace)

    def reset(self, path=None):
        self.file_widget = CustomFileManager(path, self)
        self.container.reset()

///
/// startmenu.py
import json
import os

from PySide6 import QtWidgets
from PySide6.QtWidgets import QMessageBox

from gui.main_window import Ui_MainWindow


class Ui_StartMenu(QtWidgets.QWidget):
    """
    Стартовое меню с вариантами выбора.
    """

    def __init__(self) -> None:
        """
        Initializes the start menu.
        """
        super().__init__()
        self.main_window = None
        self.open_button = None
        self.file_button = None
        self.file_input = None
        self.open_project_form = None
        self.create_button = None
        self.directory_button = None
        self.directory_input = None
        self.file_type_combobox = None
        self.create_project_form = None
        self.open_project_button = None
        self.create_project_button = None
        self.setWindowTitle('Начало')
        self.setGeometry(100, 100, 400, 300)
        self.stacked_widget = QtWidgets.QStackedWidget()
        self.setupUi()

    def setupUi(self) -> None:
        """
        Sets up the user interface.
        :return: None
        """
        # Create the initial layout with buttons
        initial_layout = QtWidgets.QVBoxLayout()

        self.create_project_button = QtWidgets.QPushButton("Создать новый проект")
        self.open_project_button = QtWidgets.QPushButton("Выбрать проект")

        self.create_project_button.clicked.connect(self.show_create_project_form)
        self.open_project_button.clicked.connect(self.show_open_project_form)

        initial_layout.addWidget(self.create_project_button)
        initial_layout.addWidget(self.open_project_button)

        initial_widget = QtWidgets.QWidget()
        initial_widget.setLayout(initial_layout)

        # Add the initial widget to the stacked widget
        self.stacked_widget.addWidget(initial_widget)

        # Create the create project form
        self.create_project_form = QtWidgets.QWidget()
        create_form_layout = QtWidgets.QFormLayout()
        self.directory_input = QtWidgets.QLineEdit()
        self.directory_input.setReadOnly(True)
        self.directory_button = QtWidgets.QPushButton("Выбрать директорию")
        self.directory_button.clicked.connect(self.select_directory)

        self.file_type_combobox = QtWidgets.QComboBox()
        self.file_type_combobox.addItems(["Все файлы (*)", "Текстовые файлы (*.txt)", "Python файлы (*.py)"])

        self.create_button = QtWidgets.QPushButton("Создать проект")
        self.create_button.clicked.connect(self.create_project_with_form)

        create_form_layout.addRow("Директория:", self.directory_input)
        create_form_layout.addRow("", self.directory_button)
        create_form_layout.addRow("Тип файла:", self.file_type_combobox)
        create_form_layout.addRow("", self.create_button)

        self.create_project_form.setLayout(create_form_layout)
        self.stacked_widget.addWidget(self.create_project_form)

        # Create the open project form
        self.open_project_form = QtWidgets.QWidget()
        open_form_layout = QtWidgets.QFormLayout()
        self.file_input = QtWidgets.QLineEdit()
        self.file_input.setReadOnly(True)
        # self.file_button = QtWidgets.QPushButton("Выбрать файл")
        # self.file_button.clicked.connect(self.select_file)

        self.open_button = QtWidgets.QPushButton("Открыть проект")
        self.open_button.clicked.connect(self.open_project)

        open_form_layout.addRow("Файл:", self.file_input)
        # open_form_layout.addRow("", self.file_button)
        open_form_layout.addRow("", self.open_button)

        self.open_project_form.setLayout(open_form_layout)
        self.stacked_widget.addWidget(self.open_project_form)

        # Set the layout for the StartMenu
        main_layout = QtWidgets.QVBoxLayout()
        main_layout.addWidget(self.stacked_widget)
        self.setLayout(main_layout)

    def show_create_project_form(self) -> None:
        """
        Shows the create project form.
        :return: None
        """
        self.stacked_widget.setCurrentWidget(self.create_project_form)

    def show_open_project_form(self) -> None:
        """
        Shows the open project form.
        :return: None
        """
        self.stacked_widget.setCurrentWidget(self.open_project_form)

    def select_directory(self) -> None:
        """
        Selects a directory and sets the text of the directory input.
        :return: None
        """
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, "Выбрать директорию для нового проекта")
        if dir_path:
            self.directory_input.setText(dir_path)

    def select_file(self) -> None:
        """
        Selects a file and sets the text of the file input.
        :return: None
        """
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "Выбрать проект", "",
                                                             "Все файлы (*.mdth)")
        if file_path:
            self.file_input.setText(file_path)
            self.open_main_window(file_path)

    def create_project_with_form(self) -> None:
        """
        Creates the project form.
        :return: None
        """
        dir_path = self.directory_input.text()
        # file_type = self.file_type_combobox.currentText(encoding="utf-8")

        if dir_path:
            self.create_project(dir_path)

    def check_main_dirs(self, path):
        import os
        if not os.path.exists(f"{path}/export"):
            os.mkdir(f"{path}/export")

    def create_project(self, dir_path, file_type="*") -> None:
        """
        Creates a project directory and saves project information to a .projmd file.
        :param dir_path: Directory path for the project.
        :param file_type: Selected file type for the project.
        :return: None
        """
        if not os.path.exists(dir_path):
            os.makedirs(dir_path)

        project_data = {
            "directory": dir_path,
            "file_type": file_type
        }


        projmd_file = os.path.join(dir_path, "proj.projmd")
        with open(projmd_file, 'w') as f:
            json.dump(project_data, f, indent=4)

        from utils.configuration_config_mdt import ConfigurationMDTH
        try:
            ConfigurationMDTH.create_configuration_config_mdt(dir_path).save_as_json()
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))
        else:
            print("Configuration file created successfully.")
        self.check_main_dirs(dir_path)
        if file_type:
            self.open_main_window(dir_path, file_type)

    def open_project(self) -> None:
        """
        Opens the main window for an existing project by selecting the project directory.
        :return: None
        """
        dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, "Выбрать директорию проекта для открытия")
        if dir_path:
            projmd_file = os.path.join(dir_path, "proj.projmd")
            if os.path.isfile(projmd_file):
                with open(projmd_file, 'r') as f:
                    project_data = json.load(f)

                self.open_main_window(project_data['directory'], project_data.get('file_type'))

    def open_main_window(self, project_path, file_type=None) -> None:
        """
        Opens the main window.
        :param project_path: The path to the project.
        :param file_type: The file type.
        :return: None
        """
        self.main_window = Ui_MainWindow(**{'path': project_path, 'ft': file_type})
        self.main_window.show()
        self.close()

///